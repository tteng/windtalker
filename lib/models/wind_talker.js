// Generated by CoffeeScript 1.6.1
(function() {
  var WindTalker, fs, net, os, redis, settings, zlib,
    _this = this;

  fs = require('fs');

  zlib = require('zlib');

  net = require('net');

  os = require('os');

  settings = require('../config/settings');

  redis = require('../db/redis_util').createClient();

  WindTalker = (function() {

    function WindTalker(channel, host, port) {
      var _ref,
        _this = this;
      this.channel = channel;
      this.host = host;
      this.port = port;
      this.analyze_data = function(cursor, raw_buf) {
        return WindTalker.prototype.analyze_data.apply(_this, arguments);
      };
      this.greeting = "m=" + this.channel + ";u=" + settings.username + ";p=" + settings.password + ";EX_HEAD=a8b9c0d1;EX_SIZE=1;";
      this.client = new net.Socket();
      this.delta = new Buffer(0);
      _ref = [0, 0, false], this.message_size = _ref[0], this.head = _ref[1], this.found_head = _ref[2];
    }

    WindTalker.prototype.listen = function() {
      var _this = this;
      this.client.connect(this.port, this.host, function() {
        return _this.client.write(_this.greeting);
      });
      return this.client.on('data', function(data) {
        _this.delta = Buffer.concat([_this.delta, data]);
        if (!_this.found_head) {
          if (!(_this.delta.length < 16)) {
            _this.detect_head(_this.delta);
          }
        }
        if (_this.found_head && _this.message_size === 0) {
          _this.detect_message_size();
        }
        if (_this.message_size > 0) {
          if (_this.received_complete_message()) {
            return _this.split_buffer_and_decode();
          }
        }
      });
    };

    WindTalker.prototype.received_complete_message = function() {
      return this.delta.length >= this.head + 4 + 4 + this.message_size;
    };

    WindTalker.prototype.split_buffer_and_decode = function() {
      var wild_buf, _ref;
      wild_buf = new Buffer(this.message_size);
      wild_buf.fill(0);
      this.delta.copy(wild_buf, 0, this.head + 4 + 4, this.head + 4 + 4 + this.message_size);
      this.delta = this.delta.slice(this.head + 4 + 4 + this.message_size, this.delta.length);
      _ref = [0, 0, false], this.message_size = _ref[0], this.head = _ref[1], this.found_head = _ref[2];
      return this.decode_buf(wild_buf, 0);
    };

    WindTalker.prototype.decode_buf = function(buf, cursor) {
      var chunk_size, raw_data_buf, raw_data_size;
      if (cursor >= buf.length) {
        return;
      }
      chunk_size = buf.readUInt32LE(cursor);
      raw_data_size = buf.readUInt32LE(cursor + 4);
      try {
        raw_data_buf = new Buffer(chunk_size - 4);
        raw_data_buf.fill(0);
      } catch (error) {
        console.log("[Error][AllocateMemoryFailed]");
        raw_data_buf = null;
      }
      if (raw_data_buf) {
        buf.copy(raw_data_buf, 0, cursor + 4 + 4, cursor + 4 + 4 + chunk_size - 4);
        this.inflate_and_iterate_buf(raw_data_buf, raw_data_size);
        cursor = cursor + 4 + 4 + chunk_size - 4;
        return this.decode_buf(buf, cursor);
      }
    };

    WindTalker.prototype.inflate_and_iterate_buf = function(raw_buf, raw_data_size) {
      var _this = this;
      return zlib.inflate(raw_buf, function(error, result) {
        if (error) {
          throw error;
        } else {
          if (result.length === raw_data_size) {
            if (result.length % 156 === 0) {
              return _this.analyze_data(0, result);
            } else {
              return consloe.log("[Error] invalid buffer size");
            }
          }
        }
      });
    };

    WindTalker.prototype.detect_head = function() {
      var bite, i, _i, _len, _ref, _results;
      _ref = this.delta;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        bite = _ref[i];
        if (this.is_head(this.delta, i)) {
          this.head = i;
          this.found_head = true;
          console.log("head is: " + this.head);
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    WindTalker.prototype.detect_message_size = function() {
      if (this.delta.length >= this.head + 4 + 4) {
        console.log("load enough data to read message size");
        this.message_size = this.delta.readUInt32LE(this.head + 4);
        return console.log("message size: " + this.message_size);
      }
    };

    WindTalker.prototype.is_head = function(buff, idx) {
      var bite, result;
      result = false;
      bite = buff[idx];
      if (bite && bite.toString('16').toLowerCase() === 'd1') {
        if (buff[idx + 1] && buff[idx + 1].toString('16').toLowerCase() === 'c0') {
          if (buff[idx + 2] && buff[idx + 2].toString('16').toLowerCase() === 'b9') {
            if (buff[idx + 3] && buff[idx + 3].toString('16').toLowerCase() === 'a8') {
              result = true;
            }
          }
        }
      }
      return result;
    };

    WindTalker.prototype.stop = function() {
      return this.client.destroy();
    };

    WindTalker.prototype.analyze_data = function(cursor, raw_buf) {
      var buf, buyAmount, buyBids, contract, data, feature_price, holding, i, j, latest_deal, m_fAmount, m_fHigh, m_fLastClose, m_fLow, m_fNewPrice, m_fOpen, m_fVolume, market, result, sellAmount, sellBids, time_t, total_deal, val, _i, _j;
      if (cursor >= raw_buf.length) {
        console.log("process finished.");
        return;
      }
      data = new Buffer(156);
      data.fill(0);
      result = '';
      buf = raw_buf.copy(data, 0, cursor, cursor + 156);
      time_t = data.readUInt32LE(0);
      result += "" + time_t + ",";
      for (i = _i = 4; _i <= 15; i = ++_i) {
        if (data[i] === 0) {
          break;
        }
      }
      market = data.toString('ascii', 4, i);
      result += "" + market + ",";
      for (j = _j = 16; _j <= 31; j = ++_j) {
        if (data[j] === 0) {
          break;
        }
      }
      contract = data.toString('ascii', 16, j);
      result += "" + contract + ",";
      total_deal = data.readFloatLE(32);
      result += "" + total_deal + ",";
      latest_deal = data.readFloatLE(36);
      result += "" + latest_deal + ",";
      holding = data.readFloatLE(40);
      result += "" + holding + ",";
      feature_price = data.readFloatLE(44);
      result += "" + feature_price + ",";
      m_fLastClose = data.readFloatLE(48);
      result += "" + m_fLastClose + ",";
      m_fOpen = data.readFloatLE(52);
      result += "" + m_fOpen + ",";
      m_fHigh = data.readFloatLE(56);
      result += "" + m_fHigh + ",";
      m_fLow = data.readFloatLE(60);
      result += "" + m_fLow + ",";
      m_fNewPrice = data.readFloatLE(64);
      result += "" + m_fNewPrice + ",";
      m_fVolume = data.readFloatLE(68);
      result += "" + m_fVolume + ",";
      m_fAmount = data.readFloatLE(72);
      result += "" + m_fAmount + ",[";
      i = 0;
      buyBids = [];
      while (i < 5) {
        val = data.readFloatLE(76 + i * 4);
        buyBids.push(val);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "],[";
      i = 0;
      buyAmount = [];
      while (i < 5) {
        val = data.readFloatLE(96 + i * 4);
        buyAmount.push(val);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "],[";
      i = 0;
      sellBids = [];
      while (i < 5) {
        val = data.readFloatLE(116 + i * 4);
        sellBids.push(val);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "],[";
      i = 0;
      sellAmount = [];
      while (i < 5) {
        val = data.readFloatLE(136 + i * 4);
        sellAmount.push(val);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "]";
      this.saveToDb(time_t, market, m_fLastClose, m_fOpen, m_fHigh, m_fLow, m_fNewPrice, m_fVolume, m_fAmount);
      result = null;
      raw_buf = raw_buf.slice(cursor + 156, raw_buf.length);
      cursor = 0;
      return this.analyze_data(cursor, raw_buf);
    };

    WindTalker.prototype.saveToDb = function(time, ticker, fLastClose, fOpen, fHigh, fLow, fNewPrice, fVolume, fAmount) {
      var key;
      if (key = this.redisKey(ticker)) {
        return redis.hmset(key, {
          "t": time,
          "close": fLastClose,
          "open": fOpen,
          "high": fHigh,
          "low": fLow,
          "current": fNewPrice,
          "volume": fVolume,
          "amount": fAmount
        }, function(err, result) {
          if (result) {
            console.log(key);
          }
          if (err) {
            return console.error("[REDIS][ERROR] update " + corresponding_key + " failed for " + err + ".");
          }
        });
      }
    };

    return WindTalker;

  })();

  module.exports = WindTalker;

}).call(this);
