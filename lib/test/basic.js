// Generated by CoffeeScript 1.6.1
(function() {
  var A, Iconv, a, fs, os, zlib,
    _this = this;

  fs = require('fs');

  os = require('os');

  zlib = require('zlib');

  Iconv = require('iconv').Iconv;

  console.log("The CPU endian is " + (os.endianness()));

  A = (function() {

    function A() {
      var _this = this;
      this.analyze_data = function(cursor, raw_buf) {
        return A.prototype.analyze_data.apply(_this, arguments);
      };
    }

    A.prototype.test = function() {
      var _this = this;
      return fs.open(__dirname + "/../../data/wsSample.wsz", 'r', function(err, fd) {
        var buf;
        buf = new Buffer(4);
        buf.fill(0);
        return fs.read(fd, buf, 0, 4, 0, function(err, bytesRead, buf) {
          var current_cursor;
          current_cursor = 0;
          return _this.iterate_buf(current_cursor, buf, fd);
        });
      });
    };

    A.prototype.iterate_buf = function(cursor, buf, fd) {
      var buf_length,
        _this = this;
      if (cursor < buf.length) {
        buf_length = buf.readUInt32LE(cursor);
        console.log("buff length: " + (buf_length - 4));
        return fs.read(fd, buf, 0, 4, cursor + 4, function(err, bytesRead, buf) {
          var encrypt_data, raw_buf_length;
          raw_buf_length = buf.readUInt32LE(0);
          console.log("raw buff length: " + raw_buf_length);
          encrypt_data = new Buffer(raw_buf_length);
          encrypt_data.fill(0);
          fs.read(fd, encrypt_data, 0, raw_buf_length, 0 + 4 + 4, function(err, bytesRead, buf) {
            var analyze_data;
            analyze_data = _this.analyze_data;
            return zlib.inflate(encrypt_data, function(error, result) {
              console.log("result length: " + result.length);
              if (result.length % 156 !== 0) {
                return console.log("warning: invalid buffer size");
              } else {
                return analyze_data(0, result);
              }
            });
          });
          cursor = cursor + raw_buf_length + 4;
          return _this.iterate_buf(cursor, buf, fd);
        });
      } else {
        return console.log("cursor: " + cursor + ", reach file end, that's all.");
      }
    };

    A.prototype.analyze_data = function(cursor, raw_buf) {
      var buf, contract, data, feature_price, holding, i, latest_deal, m_fAmount, m_fHigh, m_fLastClose, m_fLow, m_fNewPrice, m_fOpen, m_fVolume, market, result, time_t, total_deal, val;
      if (cursor >= raw_buf.length) {
        console.log("process finished.");
        return;
      }
      console.log("analyzing...");
      data = new Buffer(156);
      data.fill(0);
      result = '';
      buf = raw_buf.copy(data, 0, cursor, cursor + 156 - 1);
      time_t = data.readUInt32LE(0);
      console.log("time_t: " + time_t);
      result += "" + time_t + ",";
      market = data.toString('ascii', 4, 15);
      console.log("mar: " + market);
      result += "" + market + ",";
      contract = data.toString('ascii', 16, 31);
      console.log("contract: " + contract);
      result += "" + contract + ",";
      total_deal = data.readFloatLE(32);
      console.log("total_deal: " + total_deal);
      result += "" + total_deal + ",";
      latest_deal = data.readFloatLE(36);
      console.log("latest_deal: " + latest_deal);
      result += "" + latest_deal + ",";
      holding = data.readFloatLE(40);
      console.log("holding: " + holding);
      result += "" + holding + ",";
      feature_price = data.readFloatLE(44);
      console.log("feature_price: " + feature_price);
      result += "" + feature_price + ",";
      m_fLastClose = data.readFloatLE(48);
      console.log("m_fLastClose: " + m_fLastClose);
      result += "" + m_fLastClose + ",";
      m_fOpen = data.readFloatLE(52);
      console.log("m_fOpen: " + m_fOpen);
      result += "" + m_fOpen + ",";
      m_fHigh = data.readFloatLE(56);
      console.log("m_fHigh: " + m_fHigh);
      result += "" + m_fHigh + ",";
      m_fLow = data.readFloatLE(60);
      console.log("m_fLow: " + m_fLow);
      result += "" + m_fLow + ",";
      m_fNewPrice = data.readFloatLE(64);
      console.log("m_fNewPrice: " + m_fNewPrice);
      result += "" + m_fNewPrice + ",";
      m_fVolume = data.readFloatLE(68);
      console.log("m_fNewPrice: " + m_fVolume);
      result += "" + m_fVolume + ",";
      m_fAmount = data.readFloatLE(72);
      console.log("m_fAmount: " + m_fAmount);
      result += "" + m_fAmount + ",[";
      i = 0;
      while (i < 5) {
        val = data.readFloatLE(76 + i * 4);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "],[";
      i = 0;
      while (i < 5) {
        val = data.readFloatLE(96 + i * 4);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "],[";
      i = 0;
      while (i < 5) {
        val = data.readFloatLE(116 + i * 4);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "],[";
      i = 0;
      while (i < 5) {
        val = data.readFloatLE(136 + i * 4);
        result += "" + val;
        if (i !== 4) {
          result += ",";
        }
        i += 1;
      }
      result += "]";
      console.log("result: " + result);
      result = null;
      raw_buf = raw_buf.slice(cursor + 156, raw_buf.length);
      cursor = 0;
      return this.analyze_data(cursor, raw_buf);
    };

    return A;

  })();

  a = new A();

  a.test();

}).call(this);
