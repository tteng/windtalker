// Generated by CoffeeScript 1.6.1
(function() {
  var ERROR, FLUSH_INTERVAL, INFO, LEVELS, LOG, Logger, NAME_TAG, NOOP_FN, PID, ROTATION_INTERVAL, WARN, env, fs, join, logger;

  fs = require("fs");

  env = require("./settings");

  ERROR = 3;

  WARN = 2;

  INFO = 1;

  LOG = 0;

  NOOP_FN = function() {};

  LEVELS = ["log", "info", "warn", "error"];

  PID = "[" + process.pid + "]";

  NAME_TAG = {
    "log": "LOG -",
    "info": "\u001b[32mINFO\u001b[0m -",
    "warn": "\u001b[33mWARNING\u001b[0m -",
    "error": "\u001b[31mERROR\u001b[0m -"
  };

  ROTATION_INTERVAL = 4 * 60 * 60 * 1000;

  FLUSH_INTERVAL = 5 * 1000;

  join = Array.prototype.join;

  Logger = (function() {

    function Logger() {
      this._level = LOG;
      this._path = null;
      this._resetInterval = null;
      this._flushInterval = null;
      this.setLevel(this._level);
      this.setPath(this._path);
      this._async();
    }

    Logger.prototype.setPath = function(path) {
      var _this = this;
      if (path) {
        console.info("[logger:setPath] Set logger path to: " + path);
        this._path = path;
        this._resetStream();
        if (!this._resetInterval) {
          this._resetInterval = setInterval((function() {
            return _this._resetStream();
          }), ROTATION_INTERVAL);
        }
        this._flushLog = this._flushLogToFile;
      } else {
        console.info("[logger:setPath] Use console for logger");
        this._flushLog = this._flushLogToConsole;
      }
      return this;
    };

    Logger.prototype.setLevel = function(level) {
      var i, method, _i, _len;
      if (level == null) {
        level = 0;
      }
      console.info("[logger:setPath] Set logger level to " + level);
      for (i = _i = 0, _len = LEVELS.length; _i < _len; i = ++_i) {
        method = LEVELS[i];
        if (i < level) {
          this._defineNoopMethod(method);
        } else {
          this._defineMethod(method);
        }
      }
      this._level = level;
      return this;
    };

    Logger.prototype.log = NOOP_FN;

    Logger.prototype.info = NOOP_FN;

    Logger.prototype.warn = NOOP_FN;

    Logger.prototype.error = NOOP_FN;

    Logger.prototype._defineMethod = function(name) {
      var tag,
        _this = this;
      tag = NAME_TAG[name];
      if (env.DEBUG) {
        return this[name] = function() {
          return console[name](PID, (new Date).toISOString(), tag, join.call(arguments));
        };
      } else {
        return this[name] = function() {
          _this._cache[name].push("" + PID + " " + (new Date().toISOString()) + " " + tag + " " + (join.call(arguments)) + "\r\n");
        };
      }
    };

    Logger.prototype._defineNoopMethod = function(name) {
      return this[name] = NOOP_FN;
    };

    Logger.prototype._async = function() {
      var _this = this;
      this._cache = {
        log: [],
        info: [],
        warn: [],
        error: []
      };
      return this._flushInterval = setInterval(function() {
        var key, logs, value, _ref, _results;
        _ref = _this._cache;
        _results = [];
        for (key in _ref) {
          value = _ref[key];
          if (value.length === 0) {
            continue;
          }
          logs = value.join("");
          if (_this._flushLog(key, logs)) {
            _results.push(value.length = 0);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }, 5 * 1000);
    };

    Logger.prototype._flushLogToFile = function(level, logs) {
      if (!(this._stream && this._stream.writable)) {
        this._flushLogToConsole(level, logs);
        return true;
      }
      this._stream.write(logs);
      return true;
    };

    Logger.prototype._flushLogToConsole = function(level, logs) {
      console[level](logs);
      return true;
    };

    Logger.prototype._resetStream = function() {
      var day, logPath, month, options, today, year;
      if (!this._path) {
        return;
      }
      today = new Date();
      year = "" + (today.getFullYear());
      month = "" + (today.getMonth() + 1);
      if (!month[1]) {
        month = "0" + month;
      }
      day = "" + (today.getDate());
      if (!day[1]) {
        day = "0" + day;
      }
      logPath = this._path.replace("%Y", year).replace("%m", month).replace("%d", day);
      if (logPath === this._realPath) {
        return;
      }
      this._realPath = logPath;
      options = {
        flags: 'a',
        encoding: 'utf-8',
        mode: '0644'
      };
      if (this._stream) {
        try {
          this._stream.destroySoon();
        } catch (error) {
          this.error("[logger:_resetStream] Failed to close stream. Error: " + error);
        }
      }
      try {
        this._stream = fs.createWriteStream(logPath, options);
        logger.info("[logger:_resetStream] Rotate to new log path: " + logPath);
      } catch (error) {
        this.error("[logger:_resetStream] Failed to create stream. Error: " + error);
        this._stream = null;
      }
    };

    return Logger;

  })();

  logger = new Logger();

  logger.ERROR = ERROR;

  logger.WARN = WARN;

  logger.INFO = INFO;

  logger.LOG = LOG;

  module.exports = logger;

}).call(this);
