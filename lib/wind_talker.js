// Generated by CoffeeScript 1.6.1
(function() {
  var WindTalker, fs, net, os, w, zlib;

  fs = require('fs');

  zlib = require('zlib');

  net = require('net');

  os = require('os');

  WindTalker = (function() {

    function WindTalker(channel, host, port) {
      var _ref;
      this.channel = channel;
      this.host = host != null ? host : "121.199.14.113";
      this.port = port != null ? port : 7781;
      this.delimiter_ary = ['a8', 'b9', 'c0', 'd1'];
      this.greeting = "m=" + this.channel + ";u=dellsha01;p=jason3802;EX_HEAD=a8b9c0d1;EX_SIZE=1;";
      this.client = new net.Socket();
      this.delta = new Buffer(0);
      _ref = [0, 0, false], this.message_size = _ref[0], this.head = _ref[1], this.found_head = _ref[2];
      console.log("The cpu endian is " + (os.endianness()));
    }

    WindTalker.prototype.listen = function() {
      var _this = this;
      this.client.connect(this.port, this.host, function() {
        console.log("Connect to " + _this.host + ":" + _this.port);
        return _this.client.write(_this.greeting);
      });
      this.client.on('data', function(data) {
        var bite, chunk_size, i, raw_data_size, _i, _len, _ref;
        _this.delta = Buffer.concat([_this.delta, data]);
        if (!_this.found_head) {
          if (!(_this.delta.length < 16)) {
            _ref = _this.delta;
            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
              bite = _ref[i];
              if (_this.isHead(data, i)) {
                _this.head = i;
                _this.found_head = true;
                break;
              }
            }
          }
          if (_this.found_head) {
            _this.message_size = _this.delta.readUInt32LE(_this.head + 4);
            chunk_size = _this.delta.readUInt32LE(_this.head + 4 + 4);
            raw_data_size = _this.delta.readUInt32LE(_this.head + 4 + 4 + 4);
            console.log("bingooo, got the head:" + _this.head + ".");
            console.log("message_size: " + _this.message_size + ", chunk_size: " + chunk_size + ", raw_data_size: " + raw_data_size);
          }
        }
        if (_this.found_head && _this.delta.length >= (_this.head + 4 + 4 + _this.message_size)) {
          console.log("have received a complete message, delta length: " + _this.delta.length);
          _this.delta = _this.delta.slice(_this.head + _this.message_size, _this.delta.length);
          _this.found_head = false;
          return console.log("after slice, delta length: " + _this.delta.length + ", found_head: " + _this.found_head);
        } else {
          return console.log("continue receiving ...");
        }
      });
      return this.client.on('close', function() {
        return console.log("Connection closed.");
      });
    };

    WindTalker.prototype.split_and_inflate = function(current_cursor, end_point) {
      var chunk_end, chunk_size, chunk_start, compressed_data, raw_data_size,
        _this = this;
      if (current_cursor < end_point) {
        console.log("current_cursor: " + current_cursor);
        chunk_size = this.delta.readUInt32LE(current_cursor);
        raw_data_size = this.delta.readUInt32LE(current_cursor + 4);
        console.log("----------- current cursor is " + current_cursor + " ----------------");
        chunk_start = current_cursor + 8;
        chunk_end = chunk_start + chunk_size - 1;
        console.log("chunk_size: " + chunk_size);
        console.log("raw_data_size: " + raw_data_size);
        compressed_data = new Buffer(chunk_size);
        compressed_data.fill(0);
        this.delta.copy(compressed_data, 0, chunk_start, chunk_end);
        return zlib.inflate(compressed_data, function(error, result) {
          if (error) {
            throw error;
          }
          console.log("uncompressed data size: " + result.length);
          console.log("current_cursor in callback: " + current_cursor);
          current_cursor = chunk_end + 1 - 4;
          console.log("next current cursor should be: " + current_cursor);
          console.log("end_point in callback: " + end_point);
          return _this.split_and_inflate(current_cursor, end_point);
        });
      }
    };

    WindTalker.prototype.isHead = function(buff, idx) {
      var bite, result;
      result = false;
      bite = buff[idx];
      if (bite && bite.toString('16').toLowerCase() === 'd1') {
        if (buff[idx + 1] && buff[idx + 1].toString('16').toLowerCase() === 'c0') {
          if (buff[idx + 2] && buff[idx + 2].toString('16').toLowerCase() === 'b9') {
            if (buff[idx + 3] && buff[idx + 3].toString('16').toLowerCase() === 'a8') {
              result = true;
            }
          }
        }
      }
      return result;
    };

    return WindTalker;

  })();

  w = new WindTalker('IX');

  w.listen();

}).call(this);
